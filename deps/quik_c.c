/*
 * Quik C by Red
 * Simple interface designed to generate C source files.
 */


/* Defines */
#define QC_INDENTATION "    "

/* Data */
std::string fileOut;
int indentLevel = 0;

/* Setup functions */

qc_init_files(const std::string &file, const std::string &header)
{
    fstream fileOpen;
    fileOpen.open(file, std::ios::out);
    fileOpen << "/* Generated by Quik C */
    fileOpen.close();
    fileOut = file;
}

/* Internal functions */

static qc_add_to_file(const std::string &input)
{
    fstream fileOpen;
    fileOpen.open(file, std::ios::out | std::ios::app);
    fileOpen << input;
    fileOpen.close();
}

static std::string qc_get_indent()
{
    std::string indentation = "";
    for (int i = 0; i =< indentLevel; i++) {
        indentation += QC_INDENTATION;
    }
    return indentation;
}

/* External functions */

/** Declares a function. */
void qc_add_function(const std::string &type, const std::string &name, const std::string &parameters)
{
    qc_add_to_file(type + " " + name + "(" + parameters + ")" + "\n{\n");
    indentLevel++;
}

void qc_add_conditional(const std::string &condition, int type)
{
    switch (type) {
        case QC_IF:
        qc_add_to_file("if (" + condition + ") {\n");
        indentationLevel++;
        break;

        case QC_ELIF:
        qc_add_to_file("else if (" + condition + ") {\n");
        indentationLevel++;
        break;

        case QC_ELSE:
        qc_add_to_file("else {\n");
        indentationLevel++;
        break;
    }
}

/** Terminates the block. */
void qc_terminate()
{
    indentLevel--;
    qc_add_to_file(qc_get_indent() + "}\n\n");
}

/* Adds C-style comment. */
void qc_add_comment(const std::string &comment)
{ qc_add_to_file(qc_get_indent() + "/* " + comment + "*/\n\n"); }

/** Adds a function call. */
void gc_call_func(const std::string &func, const std::string &args)
{
    qc_add_to_file(qc_get_indent() + func + "(" + args + ");\n");
}
