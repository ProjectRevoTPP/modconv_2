/*
*   Copyright (c) 2019, Red                                                             *
*   All rights reserved.                                                                *
*                                                                                       *
*   Redistribution and use in source and binary forms, with or without                  *
*   modification, are permitted provided that the following conditions are met:         *  
*                                                                                       *
*       * Redistributions of source code must retain the above copyright                *
*         notice, this list of conditions and the following disclaimer.                 *
*       * Redistributions in binary form must reproduce the above copyright             *
*         notice, this list of conditions and the following disclaimer in the           *
*         documentation and/or other materials provided with the distribution.          *
*       * Neither the name of the Obsidian developers nor the                           *
*         names of its contributors may be used to endorse or promote products          *
*         derived from this software without specific prior written permission.         *
*                                                                                       *
*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND     *
*   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED       *
*   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE              *
*   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY                *
*   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          *
*   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;        *
*   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND         *
*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
*   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS       *
*   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                        *
*/

/* TODO: A lot of these can easily be cleanly converted to macros. */

#include <filesystem>
#include "common.hxx"

/* These includes aren't needed anymore due to the shift to C++17. */
/*
#ifdef _WIN32
#include <direct.h>
#else
#include <sys/stat.h>
#endif
*/

#include "../deps/lodepng.h"

/*
 * Easily accessible functions to accomplish the following tasks:
 * 1.) Reset a file (Creating is done on a per file basis with fstreams)
 * 2.) Create and reset a directory
 * 3.) Get PNG information
 * 4.) Remove filename from path
 */

/**
 * Uses fstreams to reset a plaintext file.
 * Note: Adds the modconv 2 signature to line 1.
 */
void reset_file(const std::string &fileOut)
{
    std::fstream file;
    file.open(fileOut, std::ios::out);
    file << "# Generated by modconv 2" << std::endl;
    file.close();
}

/** Deletes a directory and creates it again. */
void reset_directory(const std::string &output)
{   std::cout << "Creating directory " << output << std::endl;
    std::filesystem::create_directory(output); }

/** Uses LodePNG to get dimensions from a PNG image. */
u16 get_dimension(u8 mode, const std::string &path)
{
    u32 w, h;
    std::vector<u8> buffer;
    std::vector<u8> image;
    lodepng::load_file(buffer, path);
    lodepng::State state;
    lodepng::decode(image, w, h, state, buffer);

    if (!mode) return w;
    else return h;
}

/** Easy way to get a path leading to the directory only */
std::string get_path(const std::string &path)
{ return std::filesystem::path(path).remove_filename(); }

/** Checks if a exists (including directories) */
bool file_exists(const std::string &path)
{ return std::filesystem::exists(path); }

/** Checks if path provided is a directory */
bool is_directory(const std::string &path)
{ return std::filesystem::is_directory(path); }

/** Returns the filename only */
std::string get_filename(const std::string &path)
{ return std::filesystem::path(path).filename(); }

/** Acceptable characters */
std::string acceptableChars = "abcdefghijklmnopqrstuvwxyz0123456789",
               capitalChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/** Sanitizes input string for use with gas labels. */
std::string sanitize_output(const std::string &input)
{
    std::string toReturn = "";
    for (u16 i = 0; i < input.length(); i++)
    {
        /* Convert C++ string to lowercase because goddamnit the standard library doesn't have this built in in a sane way. */
        for (u16 j = 0; j < 25; j++)
        {
            if (input.substr(i).compare(capitalChars.substr(j)) == 0)
                toReturn += acceptableChars.substr(j);
            else
                toReturn += input.substr(i);
        }

        /* Sanitize input by removing anything not a-z 0-9 with _. */
        for (u16 k = 0; k < 35; k++)
        {
            if (input.substr(i).compare(acceptableChars.substr(k)) != 0)
                toReturn += "_";
            else
                toReturn += input.substr(i);
        }
    }
    return toReturn;
}

void copy_file(const std::string &a, const std::string &b)
{ std::filesystem::copy(a, b); }

/* Setup functions */

static void create_level_script(const std::string &output)
{
    if (!(file_exists(output + "/script.s"))) /* Don't reset if already exists. */
    {
        reset_file(output + "/script.s");
    }
}

static void create_level_geo(const std::string &output)
{
    if (!(file_exists(output + "/geo.s"))) /* Don't reset if it already exists. */
    {
        reset_file(output + "/geo.s");
    }
}

/** Creates the level header. */
static void create_level_header(const std::string &output)
{
    reset_file(output + "/header.s");
    std::fstream header;

    header.open(output + "/header.s", std::ios::out | std::ios::app);
    header << ".include " << R"(")" << "macros.inc" << R"(")" << std::endl;
    header << ".include " << R"(")" << "level_commands.inc" << R"(")" << std::endl;
    header << ".include " << R"(")" << "geo_commands.inc" << R"(")" << std::endl;

    header << "leveldata " << output << std::endl;
    header << "levelscript " << output << std::endl;
    header << "levelgeo " << output << std::endl;

    header.close();
}

static void create_level_area(const std::string &output, u8 area)
{
    std::string areaDir = output + "/areas/" + std::to_string((u16)area) + "/1";
    reset_directory(areaDir);
    reset_file(areaDir + "/model.s");
}

/* I don't know why I didn't do this originally... */

/** Sets up the output directory. */
void f3d_init_directory(const std::string &output, u8 area)
{

    reset_directory(output);

    /* Levels */
    if (area > 0)
    {
        std::cout << "DBG - Creating level directory." << std::endl;

        create_level_script(output);
        create_level_geo(output);

        create_level_area(output, area);

        /* Setup files */
        create_level_header(output);
        reset_file(output + "/texture.s"); /* The rest of this file is generated in vertex.cxx */
    }

    else /* Actors */
    {

    }
}
